'use strict';

const utils = require('@typescript-eslint/utils');

const createEslintRule = utils.ESLintUtils.RuleCreator((ruleName) => ruleName);

const RULE_NAME$2 = "if-newline";
const ifNewline = createEslintRule({
  name: RULE_NAME$2,
  meta: {
    type: "problem",
    docs: {
      description: "Newline after if",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      missingIfNewline: "Expect newline after if"
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      IfStatement(node) {
        if (!node.consequent)
          return;
        if (node.consequent.type === "BlockStatement")
          return;
        if (node.test.loc.end.line === node.consequent.loc.start.line) {
          context.report({
            node,
            loc: {
              start: node.test.loc.end,
              end: node.consequent.loc.start
            },
            messageId: "missingIfNewline",
            fix(fixer) {
              return fixer.replaceTextRange([node.consequent.range[0], node.consequent.range[0]], "\n");
            }
          });
        }
      }
    };
  }
});

const RULE_NAME$1 = "no-leading-newline";
const noLeadingNewline = createEslintRule({
  name: RULE_NAME$1,
  meta: {
    type: "problem",
    docs: {
      description: "Do not allow leading newline",
      recommended: "error"
    },
    fixable: "whitespace",
    schema: [],
    messages: {
      noLeadingNewline: "No leading newline allowed"
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      Program(node) {
        const code = context.getSourceCode();
        const match = code.text.match(/^[\s]+/)?.[0] || "";
        if (match.includes("\n")) {
          const line = match.split("\n");
          context.report({
            node,
            loc: {
              start: { line: 0, column: 0 },
              end: { line: line.length - 1, column: line[line.length - 1].length }
            },
            messageId: "noLeadingNewline",
            fix(fixer) {
              return fixer.replaceTextRange([0, match.length], "");
            }
          });
        }
      }
    };
  }
});

const RULE_NAME = "prefer-inline-type-import";
const preferInlineTypeImport = createEslintRule({
  name: RULE_NAME,
  meta: {
    type: "suggestion",
    docs: {
      description: "Newline after if",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      preferInlineTypeImport: "Prefer inline type import"
    }
  },
  defaultOptions: [],
  create: (context) => {
    const sourceCode = context.getSourceCode();
    return {
      ImportDeclaration: (node) => {
        if (node.specifiers.length === 1 && ["ImportNamespaceSpecifier", "ImportDefaultSpecifier"].includes(node.specifiers[0].type))
          return;
        if (node.importKind === "type") {
          context.report({
            *fix(fixer) {
              yield* removeTypeSpecifier(fixer, sourceCode, node);
              for (const specifier of node.specifiers)
                yield fixer.insertTextBefore(specifier, "type ");
            },
            loc: node.loc,
            messageId: "preferInlineTypeImport",
            node
          });
        }
      }
    };
  }
});
function* removeTypeSpecifier(fixer, sourceCode, node) {
  const importKeyword = sourceCode.getFirstToken(node);
  const typeIdentifier = sourceCode.getTokenAfter(importKeyword);
  yield fixer.remove(typeIdentifier);
  if (importKeyword.loc.end.column + 1 === typeIdentifier.loc.start.column) {
    yield fixer.removeRange([
      importKeyword.range[1],
      importKeyword.range[1] + 1
    ]);
  }
}

const index = {
  rules: {
    "no-leading-newline": noLeadingNewline,
    "if-newline": ifNewline,
    "prefer-inline-type-import": preferInlineTypeImport
  }
};

module.exports = index;
